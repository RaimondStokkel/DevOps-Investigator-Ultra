<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DevOps Build Investigator</title>
    <style>
      :root {
        color-scheme: dark;
      }
      body {
        margin: 0;
        font-family: Segoe UI, Arial, sans-serif;
        background: #111827;
        color: #f3f4f6;
      }
      .container {
        max-width: 900px;
        margin: 24px auto;
        padding: 0 16px;
      }
      h1 {
        font-size: 20px;
        margin: 0 0 16px;
      }
      .card {
        background: #1f2937;
        border: 1px solid #374151;
        border-radius: 8px;
        padding: 16px;
        margin-bottom: 16px;
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      select,
      button {
        height: 36px;
        border-radius: 6px;
        border: 1px solid #4b5563;
        background: #111827;
        color: #f9fafb;
        padding: 0 10px;
      }
      select {
        min-width: 460px;
        max-width: 100%;
      }
      button {
        cursor: pointer;
      }
      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .status {
        margin-top: 8px;
        color: #93c5fd;
        min-height: 20px;
      }
      pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        background: #0b1220;
        border: 1px solid #374151;
        border-radius: 8px;
        padding: 12px;
        min-height: 240px;
        max-height: 70vh;
        overflow: auto;
        margin: 0;
      }
      .small {
        color: #9ca3af;
        font-size: 12px;
        margin-top: 8px;
      }
      .subpart {
        margin-top: 14px;
        padding-top: 12px;
        border-top: 1px solid #374151;
      }
      .personality-layout {
        display: flex;
        gap: 12px;
        align-items: stretch;
        margin-top: 10px;
      }
      .repo-panel {
        flex: 1;
        min-width: 320px;
      }
      .agent-panel {
        width: 210px;
        border: 1px solid #374151;
        border-radius: 8px;
        background: #0b1220;
        padding: 10px;
      }
      .agent-panel img {
        width: 100%;
        height: auto;
        border-radius: 6px;
        border: 1px solid #374151;
        background: #111827;
      }
      .agent-panel .mood-title {
        font-size: 12px;
        color: #9ca3af;
        margin-top: 8px;
      }
      .agent-panel .mood-text {
        margin-top: 4px;
      }
      .option-list {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .option-item {
        height: auto;
        min-height: 36px;
        text-align: left;
        padding: 8px 10px;
      }
      .option-custom {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .option-custom input {
        flex: 1;
        min-width: 220px;
        height: 36px;
        border-radius: 6px;
        border: 1px solid #4b5563;
        background: #111827;
        color: #f9fafb;
        padding: 0 10px;
      }
      .debug-columns {
        display: flex;
        gap: 10px;
        margin-top: 10px;
      }
      .debug-column {
        flex: 1;
        min-width: 220px;
      }
      .debug-column pre {
        min-height: 180px;
        max-height: 40vh;
      }
      @media (max-width: 760px) {
        .personality-layout {
          flex-direction: column;
        }
        .agent-panel {
          width: auto;
        }
        .debug-columns {
          flex-direction: column;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>DevOps Build Investigation GUI</h1>

      <div class="card">
        <div class="row">
          <select id="buildSelect"></select>
          <button id="refreshBtn">Refresh failures</button>
        </div>
        <div class="row" style="margin-top: 10px">
          <button id="investigateSelectedBtn">Investigate selected build</button>
          <button id="investigateLatestBtn">Investigate latest failure</button>
          <button id="stopBtn" disabled>Stop</button>
          <select id="reasoningSelect" style="min-width: 150px">
            <option value="base" selected>Reasoning: Base</option>
            <option value="expert">Reasoning: Expert</option>
          </select>
          <label style="display: inline-flex; align-items: center; gap: 6px; font-size: 13px; color: #cbd5e1; border: 1px solid #4b5563; border-radius: 6px; padding: 0 10px; height: 36px;">
            <input id="debugModeToggle" type="checkbox" /> Debug mode
          </label>
        </div>
        <div class="status" id="status"></div>
        <div class="small">Only one investigation runs at a time.</div>

        <div class="subpart">
          <strong>Repo Index</strong>
          <div class="personality-layout">
            <div class="repo-panel">
              <div class="row">
                <input id="repoBasePathInput" type="text" placeholder="C:\\Repo" style="min-width: 380px; height: 36px; border-radius: 6px; border: 1px solid #4b5563; background: #111827; color: #f9fafb; padding: 0 10px;" />
                <button id="saveBasePathBtn">Set repo location</button>
              </div>
              <div class="row" style="margin-top: 10px">
                <button id="loadIndexBtn">Load index info</button>
                <button id="rescanIndexBtn">Rescan C:\Repo</button>
              </div>
              <div class="small" id="indexStatus"></div>
            </div>

            <div class="agent-panel">
              <img id="agentMoodImage" src="/moods/open.svg" alt="Agent mood" />
              <div class="mood-title">Agent mood</div>
              <div class="mood-text" id="agentMoodText">Ready to investigate.</div>
            </div>
          </div>
        </div>
      </div>

      <div class="card">
        <strong>Result</strong>
        <pre id="result">No investigation started.</pre>
        <div class="small" id="optionsStatus"></div>
        <div class="option-list" id="optionsList"></div>
        <div class="option-custom" style="margin-top: 10px">
          <input id="customFollowupInput" type="text" placeholder="Type any follow-up response..." />
          <button id="customFollowupSendBtn" class="option-item">Send follow-up</button>
        </div>
      </div>

      <div class="card" id="debugCard" style="display: none;">
        <div class="row">
          <strong>Debug</strong>
          <button id="debugRefreshToolsBtn">Refresh tools</button>
        </div>
        <div class="small" id="debugStatus">Debug mode is off.</div>
        <div class="debug-columns">
          <div class="debug-column">
            <div class="small">Available tools</div>
            <pre id="debugTools">No data.</pre>
          </div>
          <div class="debug-column">
            <div class="small">Tool calls</div>
            <pre id="debugToolCalls">No data.</pre>
          </div>
          <div class="debug-column">
            <div class="small">Model / tokens / cache</div>
            <pre id="debugTelemetry">No data.</pre>
          </div>
        </div>
      </div>
    </div>

    <script>
      const buildSelect = document.getElementById("buildSelect");
      const refreshBtn = document.getElementById("refreshBtn");
      const investigateSelectedBtn = document.getElementById("investigateSelectedBtn");
      const investigateLatestBtn = document.getElementById("investigateLatestBtn");
      const stopBtn = document.getElementById("stopBtn");
      const reasoningSelect = document.getElementById("reasoningSelect");
      const debugModeToggle = document.getElementById("debugModeToggle");
      const repoBasePathInput = document.getElementById("repoBasePathInput");
      const saveBasePathBtn = document.getElementById("saveBasePathBtn");
      const loadIndexBtn = document.getElementById("loadIndexBtn");
      const rescanIndexBtn = document.getElementById("rescanIndexBtn");
      const indexStatusEl = document.getElementById("indexStatus");
      const statusEl = document.getElementById("status");
      const resultEl = document.getElementById("result");
      const optionsStatusEl = document.getElementById("optionsStatus");
      const optionsListEl = document.getElementById("optionsList");
      const customFollowupInput = document.getElementById("customFollowupInput");
      const customFollowupSendBtn = document.getElementById("customFollowupSendBtn");
      const agentMoodImage = document.getElementById("agentMoodImage");
      const agentMoodText = document.getElementById("agentMoodText");
      const debugCard = document.getElementById("debugCard");
      const debugStatusEl = document.getElementById("debugStatus");
      const debugToolsEl = document.getElementById("debugTools");
      const debugToolCallsEl = document.getElementById("debugToolCalls");
      const debugTelemetryEl = document.getElementById("debugTelemetry");
      const debugRefreshToolsBtn = document.getElementById("debugRefreshToolsBtn");
      let eventSource = null;
      let shouldAutoScroll = true;
      const MAX_DEBUG_LINES = 120;

      const AGENT_MOODS = {
        open: { src: "/moods/open.svg", text: "Ready to investigate." },
        thinking: { src: "/moods/thinking.svg", text: "Thinking through logs and tools..." },
        question: { src: "/moods/question.svg", text: "I have a question for you." },
        done: { src: "/moods/done.svg", text: "Investigation complete." },
        error: { src: "/moods/error.svg", text: "Something went wrong. Check the error and try again." },
      };

      function setAgentMood(mood) {
        const data = AGENT_MOODS[mood] || AGENT_MOODS.open;
        agentMoodImage.src = data.src;
        agentMoodText.textContent = data.text;
      }

      function setBusy(isBusy) {
        refreshBtn.disabled = isBusy;
        investigateSelectedBtn.disabled = isBusy;
        investigateLatestBtn.disabled = isBusy;
        buildSelect.disabled = isBusy;
        stopBtn.disabled = !isBusy;
        debugModeToggle.disabled = isBusy;
        optionsListEl.querySelectorAll("button, input").forEach((el) => {
          el.disabled = isBusy;
        });
        customFollowupInput.disabled = isBusy;
        customFollowupSendBtn.disabled = isBusy;
        debugRefreshToolsBtn.disabled = isBusy;
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function setIndexStatus(text) {
        indexStatusEl.textContent = text;
      }

      function setIndexBusy(isBusy) {
        repoBasePathInput.disabled = isBusy;
        saveBasePathBtn.disabled = isBusy;
        loadIndexBtn.disabled = isBusy;
        rescanIndexBtn.disabled = isBusy;
      }

      function appendResult(text) {
        resultEl.textContent += text;
        if (shouldAutoScroll) {
          resultEl.scrollTop = resultEl.scrollHeight;
        }
      }

      function setDebugStatus(text) {
        debugStatusEl.textContent = text;
      }

      function setDebugVisible() {
        const enabled = debugModeToggle.checked;
        debugCard.style.display = enabled ? "block" : "none";
        if (!enabled) {
          setDebugStatus("Debug mode is off.");
        }
      }

      function appendDebugLine(preEl, line) {
        const existing = preEl.textContent === "No data." ? "" : preEl.textContent;
        const combined = (existing ? `${existing}\n` : "") + line;
        const lines = combined.split("\n");
        const trimmed = lines.slice(-MAX_DEBUG_LINES).join("\n");
        preEl.textContent = trimmed || "No data.";
        preEl.scrollTop = preEl.scrollHeight;
      }

      function appendDebugToolCall(name, args) {
        const timestamp = new Date().toLocaleTimeString();
        appendDebugLine(debugToolCallsEl, `[${timestamp}] ${name}(${args})`);
      }

      function appendDebugTelemetry(payload) {
        const timestamp = new Date().toLocaleTimeString();
        const summary = {
          time: timestamp,
          stage: payload.stage || "unknown",
          callType: payload.callType || "",
          deployment: payload.deployment || payload.modelDeployment || "",
          model: payload.model || "",
          apiVersion: payload.apiVersion || "",
          status: payload.status || "",
          finishReason: payload.finishReason || "",
          usage: payload.usage || null,
          cacheHeaders: payload.headers
            ? Object.fromEntries(Object.entries(payload.headers).filter(([key]) => /cache|request-id|openai|x-ms/i.test(key)))
            : undefined,
          toolCount: payload.toolCount,
          outputChars: payload.outputChars,
          toolCallCount: payload.toolCallCount,
        };
        appendDebugLine(debugTelemetryEl, JSON.stringify(summary));
      }

      function renderAvailableToolsFromList(tools) {
        if (!Array.isArray(tools) || tools.length === 0) return;
        const lines = [];
        lines.push(`Total: ${tools.length}`);
        lines.push("");
        for (const tool of tools) {
          lines.push(`- ${tool.name}: ${tool.description || ""}`);
        }
        debugToolsEl.textContent = lines.join("\n");
      }

      function clearDebugStreams() {
        debugToolCallsEl.textContent = "No data.";
        debugTelemetryEl.textContent = "No data.";
      }

      async function loadDebugTools() {
        if (!debugModeToggle.checked) return;
        setDebugStatus("Loading available tools...");
        try {
          const response = await fetch("/api/debug/tools");
          const data = await response.json();
          if (!response.ok) {
            if (response.status === 404) {
              setDebugStatus("Tools endpoint not available in current GUI process. Tool list will load from debug stream when investigation starts.");
              return;
            }
            throw new Error(data.error || "Failed to load debug tools");
          }

          const lines = [];
          lines.push(`Total: ${data.totals?.combined ?? 0} (ADO: ${data.totals?.ado ?? 0}, Local: ${data.totals?.local ?? 0})`);
          lines.push("");
          lines.push("ADO tools:");
          for (const tool of data.adoTools || []) {
            lines.push(`- ${tool.name}: ${tool.description}`);
          }
          lines.push("");
          lines.push("Local tools:");
          for (const tool of data.localTools || []) {
            lines.push(`- ${tool.name}: ${tool.description}`);
          }
          debugToolsEl.textContent = lines.join("\n") || "No data.";
          setDebugStatus("Debug tools loaded.");
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setDebugStatus(`Error: ${message}`);
        }
      }

      function clearFollowupOptions() {
        optionsListEl.innerHTML = "";
        optionsStatusEl.textContent = "";
      }

      function extractFollowupOptions(summaryText) {
        if (!summaryText) return [];

        const lines = summaryText.split(/\r?\n/);
        const options = [];

        function cleanOption(text) {
          return text
            .replace(/^[-*‚Ä¢]\s*/, "")
            .replace(/^\d+[\).:-]\s*/, "")
            .replace(/^[‚úÖ‚òëÔ∏è‚úîüëâüîπüî∏üìå]\s*/, "")
            .replace(/\*\*/g, "")
            .trim();
        }

        function collectNumberedFrom(startIdx) {
          const numbered = [];
          for (let i = startIdx; i < lines.length; i++) {
            const line = lines[i].trim();
            if (!line) {
              if (numbered.length > 0) break;
              continue;
            }

            if (/^(reply with a number|just say|investigation complete|---)/i.test(line) && numbered.length > 0) {
              break;
            }

            const numberMatch = line.match(/^\s*(\d+)[\).:-]\s+(.+)$/);
            if (numberMatch) {
              const cleaned = cleanOption(numberMatch[2]);
              if (cleaned) numbered.push(cleaned);
              continue;
            }

            if (numbered.length > 0) {
              break;
            }
          }
          return numbered;
        }

        const choicesIdx = lines.findIndex((line) => /^\s*choices\s*:?\s*$/i.test(line));
        if (choicesIdx >= 0) {
          const choiceOptions = collectNumberedFrom(choicesIdx + 1);
          if (choiceOptions.length > 0) {
            return choiceOptions;
          }
        }

        const markerIdx = lines.findIndex((line) =>
          /(if you want.*i can|next.*i can|choose|options|follow-up)/i.test(line)
        );

        if (markerIdx >= 0) {
          const numberedAfterMarker = collectNumberedFrom(markerIdx + 1);
          if (numberedAfterMarker.length > 0) {
            return numberedAfterMarker;
          }
        }

        const startIdx = markerIdx >= 0 ? markerIdx + 1 : 0;
        for (let i = startIdx; i < lines.length; i++) {
          const line = lines[i].trim();
          if (!line) {
            if (options.length > 0) break;
            continue;
          }

          if (/^(reply with a number|just tell me|investigation complete|---)/i.test(line) && options.length > 0) {
            break;
          }

          const numberMatch = line.match(/^\s*(\d+)[\).:-]\s+(.+)$/);
          if (numberMatch) {
            const cleaned = cleanOption(numberMatch[2]);
            if (cleaned) options.push(cleaned);
            continue;
          }

          const bulletMatch = line.match(/^[-*‚Ä¢]\s*(.+)$/);
          if (bulletMatch) {
            const cleaned = cleanOption(bulletMatch[1]);
            if (cleaned) options.push(cleaned);
          }
        }

        return Array.from(new Set(options));
      }

      function renderFollowupOptions(options) {
        clearFollowupOptions();

        const hasOptions = Array.isArray(options) && options.length > 0;
        setAgentMood("question");
        optionsStatusEl.textContent = hasOptions
          ? "Follow-up options (click one to continue), or type your own response:"
          : "Follow-up action: type any response to continue the investigation.";

        if (hasOptions) {
          options.forEach((optionText, index) => {
            const button = document.createElement("button");
            button.className = "option-item";
            button.textContent = `${index + 1}. ${optionText}`;
            button.addEventListener("click", async () => {
              await investigate({
                mode: "query",
                query: `Please proceed with option ${index + 1}: ${optionText}`,
              });
            });
            optionsListEl.appendChild(button);
          });
        }

      }

      async function submitCustomFollowup() {
        const query = customFollowupInput.value.trim();
        if (!query) return;
        await investigate({ mode: "query", query });
        customFollowupInput.value = "";
      }

      function formatFailure(f) {
        const finished = f.finishTime ? new Date(f.finishTime).toLocaleString() : "unknown time";
        return `${f.id} | ${f.pipeline} | ${f.buildNumber} | ${finished}`;
      }

      async function loadFailures() {
        setStatus("Loading recent failed builds...");
        const response = await fetch("/api/failures");
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || "Failed to load failures");
        }

        buildSelect.innerHTML = "";

        if (!data.failures || data.failures.length === 0) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "No failed builds found";
          buildSelect.appendChild(option);
          setStatus("No failed builds found.");
          return;
        }

        for (const failure of data.failures) {
          const option = document.createElement("option");
          option.value = String(failure.id);
          option.textContent = formatFailure(failure);
          buildSelect.appendChild(option);
        }

        setStatus(`Loaded ${data.failures.length} failed builds.`);
      }

      async function investigate(payload) {
        setBusy(true);
        setAgentMood("thinking");
        setStatus("Running investigation...");
        resultEl.textContent = "";
        clearFollowupOptions();
        shouldAutoScroll = true;

        const params = new URLSearchParams();
        params.set(
          "mode",
          payload.mode === "selected" ? "selected" : payload.mode === "query" ? "query" : "latest"
        );
        if (payload.mode === "selected" && payload.buildId) {
          params.set("buildId", String(payload.buildId));
        }
        if (payload.mode === "query" && payload.query) {
          params.set("query", payload.query);
        }
        params.set("reasoning", reasoningSelect.value === "expert" ? "expert" : "base");
        if (debugModeToggle.checked) {
          params.set("debug", "1");
          clearDebugStreams();
          await loadDebugTools();
        }

        eventSource = new EventSource(`/api/investigate/stream?${params.toString()}`);

        eventSource.onmessage = (event) => {
          let data;
          try {
            data = JSON.parse(event.data);
          } catch {
            return;
          }

          if (!data || !data.type) {
            return;
          }

          if (data.type === "start") {
            appendResult(`User: ${data.userPrompt}\n\n`);
            return;
          }

          if (data.type === "turn") {
            appendResult(`\n--- Turn ${data.turn}/${data.maxTurns} ---\n`);
            return;
          }

          if (data.type === "assistant_chunk") {
            appendResult(data.chunk);
            return;
          }

          if (data.type === "tool_call") {
            appendResult(`\n\n[Tool Call] ${data.name}(${data.arguments})\n`);
            if (debugModeToggle.checked) {
              appendDebugToolCall(data.name, data.arguments);
            }
            return;
          }

          if (data.type === "tool_result") {
            appendResult(`\n[Tool Result]\n${data.content}\n`);
            return;
          }

          if (data.type === "debug") {
            if (debugModeToggle.checked && data.payload) {
              if (Array.isArray(data.payload.tools)) {
                renderAvailableToolsFromList(data.payload.tools);
                setDebugStatus("Tools loaded from live debug stream.");
              }
              appendDebugTelemetry(data.payload);
            }
            return;
          }

          if (data.type === "complete") {
            appendResult("\n\n--- Investigation Complete ---\n");
            const options = extractFollowupOptions(data.result || "");
            renderFollowupOptions(options);
            if (!options || options.length === 0) {
              setAgentMood("done");
            }
            setStatus("Investigation complete.");
            setBusy(false);
            eventSource.close();
            eventSource = null;
            return;
          }

          if (data.type === "max_turns") {
            appendResult("\n\n--- Max turns reached ---\n");
            return;
          }

          if (data.type === "canceled") {
            appendResult("\n\n--- Investigation Stopped ---\n");
            setAgentMood("open");
            setStatus("Investigation stopped.");
            return;
          }

          if (data.type === "done") {
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
            setBusy(false);
            return;
          }

          if (data.type === "error") {
            appendResult(`\n\nError: ${data.message}\n`);
            setAgentMood("error");
            setStatus("Investigation failed.");
            setBusy(false);
            if (eventSource) {
              eventSource.close();
              eventSource = null;
            }
          }
        };

        eventSource.onerror = () => {
          if (eventSource) {
            eventSource.close();
            eventSource = null;
          }
          setAgentMood("error");
          setStatus("Investigation stream disconnected.");
          setBusy(false);
        };
      }

      async function loadRepoIndex() {
        setIndexBusy(true);
        setIndexStatus("Loading repo index...");

        try {
          const response = await fetch("/api/repo-index");
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to load repo index");
          }

          if (data.basePath) {
            repoBasePathInput.value = data.basePath;
          }
          setIndexStatus(`Loaded from ${data.path}`);
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setIndexStatus(`Error: ${message}`);
        } finally {
          setIndexBusy(false);
        }
      }

      async function saveRepoBasePath() {
        const basePath = repoBasePathInput.value.trim();
        if (!basePath) {
          setIndexStatus("Enter a repository location first (for example: C:\\Repo). Then rescan.");
          return;
        }

        setIndexBusy(true);
        setIndexStatus("Saving repository location...");

        try {
          const response = await fetch("/api/repo-index/base-path", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ basePath }),
          });
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to save repository location");
          }

          repoBasePathInput.value = data.basePath || basePath;
          if (data.envOverride) {
            setIndexStatus(
              `${data.message} Note: REPO_BASE_PATH env var is set and will override file value until removed.`
            );
          } else {
            setIndexStatus(data.message || "Repository location saved. Rescan is required.");
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setIndexStatus(`Error: ${message}`);
        } finally {
          setIndexBusy(false);
        }
      }

      async function rescanRepoIndex() {
        setIndexBusy(true);
        setIndexStatus("Rescanning C:\\Repo...");

        try {
          const response = await fetch("/api/repo-index/rescan", {
            method: "POST",
          });
          const data = await response.json();

          if (!response.ok) {
            throw new Error(data.error || "Failed to rescan repo index");
          }

          setIndexStatus(
            `Rescanned ${data.basePath} (${data.lookupCount} lookup paths, ${data.repoCount} folders).`
          );
          await loadRepoIndex();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setIndexStatus(`Error: ${message}`);
          setIndexBusy(false);
        }
      }

      refreshBtn.addEventListener("click", async () => {
        try {
          setBusy(true);
          await loadFailures();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setStatus(`Error: ${message}`);
        } finally {
          setBusy(false);
        }
      });

      investigateSelectedBtn.addEventListener("click", async () => {
        const buildId = Number(buildSelect.value);
        if (!buildId) {
          setStatus("Select a failed build first.");
          return;
        }

        await investigate({ mode: "selected", buildId });
      });

      investigateLatestBtn.addEventListener("click", async () => {
        await investigate({ mode: "latest" });
      });

      stopBtn.addEventListener("click", async () => {
        try {
          const response = await fetch("/api/investigate/stop", { method: "POST" });
          const data = await response.json();
          if (!response.ok) {
            throw new Error(data.error || "Failed to stop investigation");
          }
          if (data.stopped) {
            setStatus("Stopping investigation...");
          } else {
            setStatus(data.message || "No active investigation.");
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setStatus(`Error: ${message}`);
        }
      });

      loadIndexBtn.addEventListener("click", async () => {
        await loadRepoIndex();
      });

      saveBasePathBtn.addEventListener("click", async () => {
        await saveRepoBasePath();
      });

      rescanIndexBtn.addEventListener("click", async () => {
        await rescanRepoIndex();
      });

      customFollowupSendBtn.addEventListener("click", async () => {
        await submitCustomFollowup();
      });

      customFollowupInput.addEventListener("keydown", async (event) => {
        if (event.key === "Enter") {
          event.preventDefault();
          await submitCustomFollowup();
        }
      });

      debugModeToggle.addEventListener("change", async () => {
        setDebugVisible();
        if (debugModeToggle.checked) {
          clearDebugStreams();
          await loadDebugTools();
        }
      });

      debugRefreshToolsBtn.addEventListener("click", async () => {
        await loadDebugTools();
      });

      resultEl.addEventListener("scroll", () => {
        const threshold = 24;
        const distanceFromBottom = resultEl.scrollHeight - (resultEl.scrollTop + resultEl.clientHeight);
        shouldAutoScroll = distanceFromBottom <= threshold;
      });

      (async () => {
        setAgentMood("open");
        setDebugVisible();
        try {
          setBusy(true);
          await loadFailures();
          await loadRepoIndex();
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          setStatus(`Error: ${message}`);
        } finally {
          setBusy(false);
        }
      })();
    </script>
  </body>
</html>
